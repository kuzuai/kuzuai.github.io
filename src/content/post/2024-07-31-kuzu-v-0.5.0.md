---
slug: "kuzu-0.5.0-release"
title: "Kùzu 0.5.0 Release"
description: "Release announcement for Kùzu 0.5.0"
pubDate: "July 31 2024"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher", "extensions"]
---

It's been a very productive summer for all of us at Kùzu Inc., and we are excited to announce the release of
Kùzu **0.5.0**! In this blog post, we will break down a significant list of updates that were
made to Kùzu's core in the last few months, including performance improvements, such as MVCC-based faster transactions,
new features, such as attaching to remote Kùzu and SQLite databases, Python UDFs, scanning and outputting to Json, scanning
and loading from Polars DataFrames and PyArrow tables, user-defined data types, and for a bonus usability feature a progress bar
in CLI and Kùzu Explorer! Without any further ado, let's dive in!

## Performance improvements

Performance has always been at the forefront of Kùzu's design, and this release is no exception. We've made
several improvements to the core storage and query engine to make it faster and more efficient. Below, we list two
of these updates, starting with Multi-Version Concurrency Control (MVCC), which is the most significant
addition to this release.

### MVCC

In prior releases, Kùzu imposed certain limitations on transactions. 
The biggest one was that we immediately checkpointed after each write transaction, 
which could potentially block the entire system intermittently after each transaction. 
n cases where users have to perform _many_ small write transactions, this could cause a lot more 
disk I/O and can trigger re-compressing column chunks, leading to slowdowns.

As of this release, we're very happy to announce that we've begun reworking our core transaction and concurrency control mechanisms 
towards utilizing [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control) (based on this paper: "[_Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems_](https://db.in.tum.de/~muehlbau/papers/mvcc.pdf)".

We will move towards a design similar to the one in the paper in phases. In this release we have implemented the
core design in this paper, e.g., we now have version chains of node and relationship records and
timestamp-based version resolving, but  we still limit write transactions 
to be non-concurrent in this version. Importantly, checkpointing is 
now done automatically based on the WAL size, which can be configured through `CALL checkpoint_threshold=x`. 
By default, the threshold value is 16 MB. Users can still enforce manual checkpoints via the `CHECKPOINT` statement,
deferring this operation to when there are no active transactions in the system.

These changes have led to **significant** performance improvements in data insertion. Below, we show the results of an experiment where we perform 100,000 insertions into a node table.

```cypher
CREATE NODE TABLE Person (id INT64, name STRING, age INT64, net_worth FLOAT, PRIMARY KEY (id));
```

Each insertion itself is an auto-transaction, and queries are executed through a single Kùzu connection.

```cypher
// Pass each record's values as parameters as an individual transaction
CREATE (:Person {id: $id, name: $name, age: $age, net_worth: $net_worth})
```

The timing numbers for the experiment below are from a Macbook Mini Desktop with an Apple M2 Pro CPU and 32GB DRAM.
We observed a **15x** speedup in version 0.5.0 in comparison to the previous version. Note that the
exact speedup you observe may vary depending on your write workload.

| Kùzu Version  | Time (s) | Speedup factor |
| :-----------: | -------- |----------------|
| 0.4.2         | 109.9    | --             |
| 0.5.0         | 7.5      | 14.6           |

The good news is that this is not the end of it! In our next phase of development, we will turn our attention
towards fully supporting MVCC, with no limitations on concurrent read _and_ write transactions. Although at it's core 
Kùzu is designed to be very performant on read-heavy queries, moving to MVCC is also making Kùzu performant on
transaction/write-heavy workloads, which some applications may need.

### Remote file system cache

\<To be added here\>

## Features

We have also added many new features in this release. Below, we review the main features we have added.

### Remote databases

Previously Kùzu supported attaching to several remote relational DBMSs, e.g., Postgres and DuckDB.
These RDBMS extensions support scanning and copying data from these databases into Kùzu. 
In this release, we've extended this functionality to attach to remote Kùzu databases as well. However, now instead of
just scanning the tuples, you can run read-only Cypher queries on these remote databases. Specifically,
you install the `httpfs` extension and attach to a remote Kùzu database as follows:

```sql
ATTACH 's3://kuzu-example/university' AS uw (dbtype kuzu);
```
The above command attaches a remote Kùzu database located in an S3 bucket at `s3://kuzu-example/university`, and aliases it as `uw`.
Now you can query this `uw` database in Cypher as if it's a local Kùzu database.

One common use case of this feature is if you have to query your backups. That is, you can create backups of your local Kùzu databases 
on S3 periodically. Then you can attach to any of these from the same script or a CLI and query them.
You can use the [remote file system cache feature](link-to-documentation-on-https-file-system-cache) (i.e., run `HTTP_CACHE_FILE=true`) to cache these remote Kùzu databases to improve 
your query performance, similar to how you can cache other remote databases and files.

Please see this [documentation page](link-to-documentation-on-attach-remote-kuzudb) for more information on connecting to remote Kùzu databases.

### Python UDFs

Earlier releases of Kùzu supported user-defined functions via the C++ API. In this release, we've extended
the UDF functionality to Python users as well. To register a Python UDF, it's required to provide
both a function signature and implementation. An example is shown below:

```python
# Define your function
def difference(a, b):
    return a - b

# Define the expected type of your parameters
parameters = [kuzu.Type.INT64, kuzu.Type.INT64]

# Define expected type of the returned value
return_type = kuzu.Type.INT64

# Register the UDF
conn.create_function("difference", difference, parameters, return_type)
```

Once registered, the Python UDF can be used as you would any other function in your Cypher queries:

```python
result = conn.execute("RETURN difference(133, 119)")
while result.has_next():
    print(result.get_next())
# Result
[14]
```

In the above example, we define a function `difference` in Python that takes two integers and returns their difference.
We then register this function with the Kùzu connection object `conn`, explicitly declaring the function's
expected type signature. Finally, we use the function to perform the desired operation via a Cypher query.

This can allow you to quickly extend Kùzu with new functions you need in your Python applications. However,
before writing your own UDF, do check if an equivalent Cypher function in Kùzu exists, as native functions run faster
than UDFs.

Please see this [documentation page](link-to-docs-on-python-udfs) for more information on Python UDFs.

## Scan and copy from DataFrames

If you regularly use Python DataFrame libraries to wrangle and transform your data, this section is for you!
In this release, we introduced several great new features that improve developer experience when working
with DataFrames.

### LOAD FROM Polars DataFrames and PyArrow tables

In an earlier release (0.1.0), we introduced the ability to scan from Pandas DataFrames using the `LOAD FROM` statement,
allowing you to directly scan in-memory Pandas DataFrames. We're happy to announce that we now support scanning
from _either_ Pandas _or_ Polars DataFrames, via the PyArrow interface. An example of scanning from a Polars DataFrame is shown below:

```python
import polars as pl

df = pl.DataFrame({
    "name": ["Adam", "Karissa", "Zhang"],
    "age": [30, 40, 50]
})
# Return all columns of a Polars DataFrame
res = conn.execute("LOAD FROM df RETURN *")
print(res.get_as_pl())
```
```
shape: (3, 2)
┌─────────┬─────┐
│ name    ┆ age │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ Adam    ┆ 30  │
│ Karissa ┆ 40  │
│ Zhang   ┆ 50  │
└─────────┴─────┘
```


Similarly you can also scan 
from in-memory PyArrow tables [the same way](https://docs.kuzudb.com/import/copy-from-dataframe#arrow-tables).
See the [docs](https://docs.kuzudb.com/import/copy-from-dataframe) for more
information on these features.

### COPY FROM DataFrames

`LOAD FROM` statements are used to scan external tuples and bind to variables 
in Cypher queries. In contrast, `COPY FROM` statements are the fast way to do bulk data ingestion into Kùzu. Specifically,
`COPY FROM` statement copy external data or results of sub-queries into a Kùzu node or relationship table. 
In prior releases of Kùzu, if you wanted to copy the data in Pandas DataFrom to a Kùzu table using `COPY FROM`, you
had to use a `LOAD FROM` subquery and pass that sub-query to
your `COPY FROM` statement. In the 0.5.0 release, we've
made this far simpler by allowing you to directly `COPY FROM` a DataFrame. An example is shown below:

#### Before:

```py
# Define a Pandas or Polars DataFrame
conn.execute("COPY Person FROM (LOAD FROM df RETURN *)")
```
#### Now:

```py
# Define a Pandas or Polars DataFrame
conn.execute("COPY Person FROM df")
```
This feature works for copying data from Pandas and Polars DataFrames, as well as PyArrow tables.
Checkout more details in this [documentation page](link-to-copy-from-dataframe-docs).

## New Extensions

This release also introduces two new extensions: SQLite and JSON, whose key features are described below.

### SQLite scanner

SQLite is one of the most widely deployed RDBMS systems, and we're pleased to announce our new SQLite
scanner, allowing you to easily scan and copy your data from your SQLite databases into Kùzu without
having to export it to an intermediate format. To use this feature, first install and load the SQLite extension:

```sql
INSTALL sqlite;
LOAD EXTENSION sqlite;
```

Attach a SQLite database by specifying the `dbtype` as `sqlite`:

```sql
ATTACH 'university.db' AS uw (dbtype sqlite);
```

Once the SQLite databases is attached, you can access its tables directly in Kùzu. The following
command scans a table named `person` in the `uw` database that sits in SQLite.

```sql
LOAD FROM uw.person RETURN *
```
Checkout more details in this [documentation page](link-to-attach-to-sqlite-docs).


### JSON support

In this release, we've extended Kùzu to support scanning and ingesting data from JSON files, as well
as writing data from Kùzu tables to JSON files.  You can now scan a JSON file as follows:

```sql
LOAD FROM 'data.json' RETURN *;
```

To ingest data from a JSON file, you can `COPY FROM` the JSON file using a familiar syntax:

```sql
CREATE NODE TABLE Example (a INT64, b STRING[], c DATE, PRIMARY KEY (a));
COPY Example FROM 'data.json';
```

A query result can also be exported to a JSON file:
```sql
COPY (match (n:Example) return t.*) TO 'output.json';
```

Checkout more details in this [documentation page](link-to-json-docs). Soon, we also plan to release the feature
of having a json data type in the sytem that can be used to store json documents as node or relationship properties.

## New data types

This release also implements the `DECIMAL` data type. In addition, you can now have user-defined types in Kùzu.

### Decimal

For users who require exact precision in their floating-point numbers, we've introduced the [`DECIMAL` data type](link-to-decimal-docs),
which works the same way as it does in other systems. You simply define
`DECIMAL(precision, scale)`, where `precision` is the total number of digits and `scale` is the number of
digits to the right of the decimal point.

You can explicitly cast a number (either integer or float) to a DECIMAL as follows:

```cypher
RETURN CAST(127.3, "DECIMAL(5, 2)") AS result;
```
```
┌───────────────┐
│ result        │
│ DECIMAL(5, 2) │
├───────────────┤
│ 127.30        │
└───────────────┘
```

### User-defined types

You can now define [user-defined data types](link-to-user-defined-data-types) by leveraging the built-in primitive types. As a simple toy example, you can define a
`AGE_T` type that is based on `INT8` as follows:

```cypher
CREATE TYPE AGE_T AS INT8;
CREATE NODE TABLE Person (id INT64, name STRING, age AGE_T, PRIMARY KEY(id));
```

Once the user-defined type is defined, you can use it to create additional types on top of it or use it in
complex data types, e.g., structs, you define. For example, the below `CREATE Node Table` statement
uses the `AGE_T` type in a `personInfo` struct:
```
CREATE Node Table Person (id INT64, STRUCT(age AGE_T, name STRING) as personInfo, PRIMARY KEY(id));
```

## DDL updates

Additional functions and features have also been added to the DDL in this release. Below, we list some of the
important ones.

### Create table if it does not exist

In prior releases, Kùzu used to throw an exception when trying to create a table whose name already
exists in the database. As a convenience to users, we now provide the `CREATE ... TABLE IF NOT EXISTS`
syntax to avoid a RunTime exception being raised if the table already exists. 

```sql
CREATE NODE TABLE IF NOT EXISTS UW(ID INT64, PRIMARY KEY(ID));
```
See [this documentation page](link-to-create-table-if-not-exists-docs) for further details.

### Drop table if it exists

Just like the previous case, you can now drop a table without raising an exception if it doesn't exist. This,
in conjunction with the previous feature, make it easier to manage your tables without having to check for
their existence beforehand.

```sql
DROP TABLE IF EXISTS UW;
```
See [this documentation page](link-to-drop-table-if-exists-docs) for further details.

### Create sequence

We added a [`SEQUENCE` generator](link-to-create-sequence) to the DDL to auto-generate sequences of numbers. The range and
step can be customized via optional parameters specified after the `CREATE SEQUENCE` in the DDL.
The following example shows how to create, read and update a sequence with a step of 1, a minimum value of 1,
and no maximum value.

```sql
CREATE SEQUENCE Seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1;
RETURN nextval('Seq');
RETURN currval('Seq');
```
To create the sequence, you'd first call the `nextval` function, which returns the next value in the sequence.
You can then access the current value in the sequence by calling the `currval` function.
This feature is particularly useful when you need to generate unique identifiers that differ from the identifiers
generated by [`SERIAL` data type](https://docs.kuzudb.com/cypher/data-types/serial/).

## Progress bar in CLI and Kùzu Explorer

Earlier versions did not provide adequate feedback to users when a long-executing query was running.
This was frustrating especially for long-running queries, say a large bulk ingestion done in a `COPY FROM` statement, as you
would not get any feedback on how long the query would take.
In this release, we've added a progress bar that shows the percentage of the query that has been
executed. The progress bar is only available in the CLI and Kùzu Explorer.
To enable the progress bar in either interface, use the following command:

```sql
CALL progress_bar=true;
```
For queries that take a significant amount of time to execute, the progress bar will now display
the number of pipelines that have been executed (each query is broken down into one or more pipelines), 
as well as the percentage of the data processed in a pipeline, which gives an estimate for how much of a pipeline
has executed.


![](/img/2024-07-31-release-0-5-0/progress_bar.gif)

## C API improvements

Numerous improvements were made to the C API for this release. We highlight these below:

- Replaced return values without parameters, simplifying object reuse
- Functions that can fail now return a `kuzu_state` value, streamlining error handling
- We now have utility functions such as `kuzu_date_t`, `kuzu_timestamp_t`, and `kuzu_interval_t`

## Join order hints

In certain cases, Kùzu could generate a sub-optimal join order when the obtained statistics are
inaccurate at the optimization stage of a large graph query. Starting from this release, we provide
the ability to specify join order hints to enforce a specific join strategy that bypasses Kùzu’s optimizer.
We will start investing more time on our optimizer but this feature gives you a mechanism to explicitly control 
the join order Kùzu generates to improve the performances of your workloads.
See the [details here](link-to-join-order-hint-documentation).

## Closing Remarks

Whew, that was a lot of new features and improvements! As always, we've only scratched the surface of listing the new features in
this blog post. For a much more comprehensive list, check out our [release notes](https://github.com/kuzudb/kuzu/releases/tag/v0.5.0)
on GitHub.

Our many thanks go out to the entire Kùzu team for their hard work in making this release possible. Hopefully,
you find that the new features and improvements enhance your graph workflows and allow you to more easily
bring your graph-based applications to production. We will continue to add more advanced functionality to Kùzu
in upcoming releases, such as in-memory graphs and an inbuilt graph algorithms package within Kùzu.
In the meantime, we recommend that you fire up a database using the newly released version and give these
features a try! And of course, do let us know if you have any feedback on [Discord](https://discord.gg/VtX2gw9Rug)
-- have fun using Kùzu!
