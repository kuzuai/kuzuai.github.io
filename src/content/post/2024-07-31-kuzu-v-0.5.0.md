---
slug: "kuzu-0.5.0-release"
title: "Kùzu 0.5.0 Release"
description: "Release announcement for Kùzu 0.5.0"
pubDate: "July 31 2024"
heroImage: "/img/default.png"
categories: ["release"]
authors: ["team"]
tags: ["cypher", "extensions"]
---

It's been a very productive summer for all of us at Kùzu Inc., and we are excited to announce the release of
Kùzu **0.5.0**! In this blog post, we will break down a significant list of updates that were
made to Kùzu's core in the last few months, including performance improvements, new features
and new extensions. Without any further ado, let's dive in!

## Performance improvements

Performance has always been at the forefront of Kùzu's design, and this release is no exception. We've made
several improvements to the core storage and query engine to make it faster and more efficient. Below, we list two
of these updates, starting with Multi-Version Concurrency Control (MVCC), which is the most significant
addition to this release.

### MVCC

In prior releases, Kùzu imposed certain limitations on transactions. The biggest one was that we immediately checkpointed after each write transaction, which could potentially block the entire system intermittently during large write operations. Due to these many checkpoints, we had to merge a lot more writes in our write-ahead log (WAL), making them part of our database files. In cases where users have to perform _many_ small write transactions, this could cause a lot more disk I/O and can trigger re-compressing column chunks, leading to slowdowns.

As of this release, we're very happy to announce that we've begun reworking our core transaction and concurrency-control mechanisms towards utilizing [MVCC](https://en.wikipedia.org/wiki/Multiversion_concurrency_control). These improvements are inspired by the excellent ideas in this paper: "[_Fast Serializable Multi-Version Concurrency Control for Main-Memory Database Systems_](https://db.in.tum.de/~muehlbau/papers/mvcc.pdf)".

Although we currently still limit write transactions to be non-concurrent in this version, checkpointing is now done automatically based on the WAL size, which can be configured through `CALL checkpoint_threshold=x`. By default, the threshold value is 16 MB. Users can still enforce manual checkpoints via the `CHECKPOINT` statement,
deferring this operation to when there are no active transactions in the system.

These changes have led to **significant** performance improvements in data insertion. Below, we show the results of an experiment where we perform 100,000 insertions into a node table.

```cypher
CREATE NODE TABLE Person (id INT64, name STRING, age INT64, net_worth FLOAT, PRIMARY KEY (id));
```

Each insertion itself is an auto-transaction, and queries are executed through a single Kùzu connection.

```cypher
// Pass each record's values as parameters as an individual transaction
CREATE (:Person {id: $id, name: $name, age: $age, net_worth: $net_worth})
```

The timing numbers for the experiment below are from a Macbook Mini Desktop with an Apple M2 Pro CPU and 32GB DRAM.
We observed a **15x** speedup in version 0.5.0 in comparison to the previous version. Note that the
exact speedup you observe may vary depending on your write workload.

| Kùzu Version  | Time (s) | Speedup factor |
| :-----------: | -------- | -------------- |
| 0.4.2         | 109.9    | N/A            |
| 0.5.0         | 7.5      | 14.6           |

The good news is that this is not the end of it! In our next phase of development, we will turn our attention
towards fully supporting MVCC, with no limitations on concurrent read _and_ write transactions.

### Remote file system system cache

\<To be added here\>

## Features

In this section, we describe some of the new features that we've added in this release.

### Remote databases

You can now attach a remote Kùzu database through an `httpfs` extension and query it as you would a local
database. For now, we only support read-only operations on remote databases. For example:

```sql
ATTACH 's3://kuzu-example/university' AS uw (dbtype kuzu);
```
The above command attaches a remote Kùzu database located in an S3 bucket at `s3://kuzu-example/university`, and aliases it as `uw`.
You can now query the remote database using Cypher. Note that because the
database sits remotely on object storage, the query performance may be slower than a local database
due to data transfer across the network.

The primary intent behind this feature is to allow you to create backups of your local Kùzu databases on S3,
allowing you to keep as many backups of their historical data as needed. If latency is important in your use case (e.g., serving current data for graph analytics),
we recommend that you download the entire database to the machine from which it is being queried. In the future,
we plan to support more convenience features for remote databases, so that users can more easily
manage and deploy their databases on the cloud.

### Python UDFs

Earlier releases of Kùzu supported user-defined functions via the C++ API. In this release, we've extended
the UDF functionality to Python users as well. To register a Python UDF, it's required to provide
both a function signature and implementation. An example is shown below:

```python
# Define your function
def difference(a, b):
    return a - b

# Define the expected type of your parameters
parameters = [kuzu.Type.INT64, kuzu.Type.INT64]

# Define expected type of the returned value
return_type = kuzu.Type.INT64

# Register the UDF
conn.create_function("difference", difference, parameters, return_type)
```

Once registered, the Python UDF can be used as you would any other function in your Cypher queries:

```python
result = conn.execute("RETURN difference(133, 119)")
while result.has_next():
    print(result.get_next())
# Result
[14]
```

In the above example, we define a function `difference` in Python that takes two integers and returns their difference.
We then register this function with the Kùzu connection object `conn`, explicitly declaring the function's
expected type signature. Finally, we use the function to perform the desired operation via a Cypher query.

The primary use case for Python UDFs is for tasks where the equivalent functionality doesn't
exist in Cypher. As a best practice, it's still recommended to look for an
equivalent Cypher function in Kùzu before writing your own UDFs in Python, as there are performance implications
to running pure-Python functions in your application.

## Scan and copy from DataFrames

If you regularly use Python DataFrame libraries to wrangle and transform your data, this section is for you!
In this release, we introduced several great new features that improve developer experience when working
with DataFrames.

### `LOAD FROM` DataFrames

In an earlier release (0.1.0), we introduced the ability to scan from Pandas DataFrames, allowing you
to directly scan in-memory Pandas DataFrames. We're happy to announce that we now support scanning
from _either_ Pandas _or_ Polars DataFrames, via the PyArrow interface. See the [docs](https://docs.kuzudb.com/import/copy-from-dataframe) for more
information on this.

An example of scanning from a Polars DataFrame is shown below:

```python
import polars as pl

df = pl.DataFrame({
    "name": ["Adam", "Karissa", "Zhang"],
    "age": [30, 40, 50]
})
# Return all columns of a Polars DataFrame
res = conn.execute("LOAD FROM df RETURN *")
print(res.get_as_pl())
```
```
shape: (3, 2)
┌─────────┬─────┐
│ name    ┆ age │
│ ---     ┆ --- │
│ str     ┆ i64 │
╞═════════╪═════╡
│ Adam    ┆ 30  │
│ Karissa ┆ 40  │
│ Zhang   ┆ 50  │
└─────────┴─────┘
```

Because the Polars DataFrame scanner is built on top of the PyArrow interface, you can also scan from
in-memory PyArrow tables [the same way](https://docs.kuzudb.com/import/copy-from-dataframe#arrow-tables).

### `COPY FROM` DataFrames

In prior releases of Kùzu, you had to pass a `LOAD FROM` subquery that scanned your Pandas DataFrames to
your `COPY FROM` statement to actually copy the data into a Kùzu table. In the 0.5.0 release, we've
made this far simpler, by allowing users to directly `COPY FROM` a DataFrame. An example is shown below:

#### Before:

```py
# Define a Pandas or Polars DataFrame
conn.execute("COPY Person FROM (LOAD FROM df RETURN *)")
```
#### Now:

```py
# Define a Pandas or Polars DataFrame
conn.execute("COPY Person FROM df")
```

## New data types

We introduce two new data types in this release: `DECIMAL` and user-defined types.

### Decimal

For users who require exact precision in their floating-point numbers, we've introduced the `DECIMAL` data type,
which works the same way as it does in other systems. You simply define
`DECIMAL(precision, scale)`, where `precision` is the total number of digits and `scale` is the number of
digits to the right of the decimal point.

You can explicitly cast a number (either integer or float) to a DECIMAL as follows:

```cypher
RETURN CAST(127.3, "DECIMAL(5, 2)") AS result;
```
```
┌───────────────┐
│ result        │
│ DECIMAL(5, 2) │
├───────────────┤
│ 127.30        │
└───────────────┘
```

### User-defined types

You can now define custom data types by leveraging built-in primitive types. For example, you can define a
`MYBIGINT` type that is based on `INT64` as follows:

```cypher
CREATE TYPE MYBIGINT AS INT64;
CREATE NODE TABLE Person (id MYBIGINT, name STRING, age BIGINT, PRIMARY KEY(id));
```

Once the user-defined type is defined, you can use it to create additional types on top of it, as follows:
```cypher
CREATE TYPE BIGLENGTH AS BIGINT;
RETURN CAST(53645636340 AS BIGLENGTH) AS biglength;
```
```
┌─────────────┐
│ biglength   │
│ INT64       │
├─────────────┤
│ 53645636340 │
└─────────────┘
```

## New Extensions

This release also introduces two new extensions: SQLite and JSON, whose key features are described below.

### SQLite scanner

SQLite is one of the most widely deployed RDBMS systems, and we're pleased to announce our new SQLite
scanner, allowing you to easily scan and copy your data from your SQLite databases into Kùzu without
having to export it to an intermediate format.

To use this feature, first install and load the SQLite extension:

```sql
INSTALL sqlite;
LOAD EXTENSION sqlite;
```

Attach a SQLite database by specifying the `dbtype` as `sqlite`:

```sql
ATTACH 'university.db' AS uw (dbtype sqlite);
```

Once the SQLite databases is attached, you can access its tables directly in Kùzu. The following
command scans a table named `person` in the `uw` database that sits in SQLite.

```sql
LOAD FROM uw.person RETURN *
```

### JSON support

In this release, we've extended Kùzu to support scanning and ingesting data from JSON files, as well
as writing data from Kùzu tables to JSON files.

You can now scan a JSON file as follows:

```sql
LOAD FROM 'data.json' RETURN *;
```

To ingest data from a JSON file, you can `COPY FROM` the JSON file using a familiar syntax:

```sql
CREATE NODE TABLE Example (a INT64, b STRING[], c DATE, PRIMARY KEY (a));
COPY Example FROM 'data.json';
```

A query result can also be exported to a JSON file:
```sql
COPY (match (n:Example) return t.*) TO 'data2.json';
```

In general, JSON can be specified as you would any other data type in the system. To define a table with JSON columns,
you can use the following syntax:

```sql
CREATE NODE TABLE Example2 (id INT64, col1 JSON, PRIMARY KEY id);
```
We hope that these features make it easier for users to work with JSON data either upstream or downstream of their
Kùzu graph database.

## DDL updates

Additional functions and features have been added to the DDL in this release. Below, we list some of the
important ones.

### Create sequence

We added a `SEQUENCE` generator to the DDL to auto-generate sequences of numbers. The range and
step can be customized via optional parameters specified after the `CREATE SEQUENCE` in the DDL.
The following example shows how to create, read and update a sequence with a step of 1, a minimum value of 1,
and no maximum value.

```sql
CREATE SEQUENCE Seq INCREMENT 1 MINVALUE 1 NO MAXVALUE START 1;
RETURN nextval('Seq');
RETURN currval('Seq');
```
To create the sequence, you'd first call the `nextval` function, which returns the next value in the sequence.
You can then access the current value in the sequence by calling the `currval` function.

### Create table if it does not exist

In prior releases, Kùzu used to throw an exception when trying to create a table whose name already
exists in the database. As a convenience to users, we now provide the `CREATE ... TABLE IF NOT EXISTS`
syntax to avoid a RunTime exception being raised if the table already exists.

```sql
CREATE NODE TABLE IF NOT EXISTS UW(ID INT64, PRIMARY KEY(ID));
```

### Drop table if it exists

Just like the previous case, you can now drop a table without raising an exception if it doesn't exist. This,
in conjunction with the previous feature, make it easier to manage your tables without having to check for
their existence beforehand.

```sql
DROP TABLE IF EXISTS UW;
```

## Progress bar in CLI and Kùzu Explorer

Earlier versions did not provide adequate feedback to users when a long-executing query was running.
In this release, we've added a progress bar that shows the percentage of the query that has been
executed. The progress bar is only available in the CLI and Kùzu Explorer.

To enable the progress bar in either interface, use the following command:

```sql
CALL progress_bar=true;
```
For queries that take a significant amount of time to execute, the progress bar will now display
the number of pipelines that have been executed, as well as the percentage of the total number of
pipelines that have been executed thus far.


![](/img/2024-07-31-release-0-5-0/progress_bar.gif)

## C API improvements

Numerous improvements were made to the C APIs for this release. We highlight these below:

- Replaced return values without parameters, simplifying object reuse
- Make functions that could fail now return a `kuzu_state` value, streamlining error handling
- Added data type utility functions such as `kuzu_date_t`, `kuzu_timestamp_t`, and `kuzu_interval_t`

## Join order hints

In certain cases, Kùzu could generate a sub-optimal join order when the obtained statistics are
inaccurate at the optimization stage of a large graph query. Starting from this release, we provide
users the ability to specify join order hints to enforce a specific join strategy that bypasses Kùzu’s optimizer.

As an example, for the following query, the optimizer picks a plan that scans from `a` due the specified predicate `a.ID = 0`.

```cypher
MATCH (a)-[e]->(b)
WHERE a.ID = 0
RETURN *;
```

You can instead force a plan that scans from `b` with following hint:

```cypher
MATCH (a)-[e]->(b)
WHERE a.ID = 0
HINT a JOIN (e JOIN b)
RETURN *;
```

It is also possible to enforce a multi-way join that uses a WCOJ join plan:

```cypher
MATCH (a:person)<-[e1:knows]-(b:person)-[e2:knows]->(c:person), (a)-[e3:knows]->(c)
HINT (((a JOIN e1) JOIN b) MULTI_JOIN e2 MULTI_JOIN e3) JOIN c
RETURN COUNT(*)
```

Providing users with more explicit control over the join plans can help in improving performance
across a broader range of query workloads.

## Closing Remarks

Whew, that was a lot of new features and improvements! As always, we've only scratched the surface of listing the new features in
this blog post. For a much more comprehensive list, check out our [release notes](https://github.com/kuzudb/kuzu/releases/tag/v0.5.0)
on GitHub.

Our many thanks go out to the entire Kùzu team for their hard work in making this release possible. Hopefully,
you find that the new features and improvements enhance your graph workflows and allow you to more easily
bring your graph-based applications to production. We will continue to add more advanced functionality to Kùzu
in upcoming releases, such as in-memory graphs and an inbuilt graph algorithms package within Kùzu.
In the meantime, we recommend that you give fire up a database using the newly released version and give these
features a try! And of course, do let us know if you have any feedback on [Discord](https://discord.gg/VtX2gw9Rug)
-- have fun using Kùzu!
